import nodeRepl from 'repl';
import { parseArgsStringToArgv } from 'string-argv';
import { autocompleter } from './autocompleter.js';
/**
 * Create new REPL instance.
 */
export function repl(program) {
    return new Repl(program);
}
export class Repl {
    constructor(program) {
        this.program = program;
        this.successHandler = () => { };
        this.errorHandler = (reason) => console.error(reason);
        this.autocompleter = autocompleter(program);
        // Stop the server to avoid eval'ing stdin from prompts
        this.program.on('run', () => {
            this.stop();
        });
    }
    attachHistory(history) {
        this.history = history;
    }
    /**
     * Start the REPL server. This method may change at any time, not
     * intended for public use.
     *
     * @private
     */
    async start() {
        var _a;
        this.server = nodeRepl.start({
            prompt: this.program.options.prompt,
            eval: this.eval.bind(this),
            completer: this.completer.bind(this),
            ignoreUndefined: true,
        });
        // Setup history
        (_a = this.history) === null || _a === void 0 ? void 0 : _a.hydrateReplServer(this.server);
        // Fixes bug with hidden cursor after enquirer prompt, this is identical to
        // the enquirer method Prompt.cursorShow()
        process.stdout.write(`\u001b[?25h`);
    }
    stop() {
        var _a;
        (_a = this.server) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Emulates promise.then, but saves the callback instead to be executed on
     * each command which resolves.
     */
    then(cb) {
        this.successHandler = cb;
        return this;
    }
    /**
     * Emulates promise.catch, but saves the callback instead to be executed on
     * each command which rejects.
     */
    catch(cb) {
        this.errorHandler = cb;
        return this;
    }
    /**
     * Invokes the autocompleter and passes results to the REPL server.
     */
    async completer(line, cb) {
        function addSpace(str) {
            return `${str} `;
        }
        const argv = parseArgsStringToArgv(line);
        const current = argv.slice(-1).toString();
        const completions = (await this.autocompleter.completions(argv)).map(addSpace);
        let hits = completions.filter((completion) => completion.startsWith(current));
        // Show all completions if none found
        cb(null, [hits.length ? hits : completions, current]);
    }
    /**
     * Uses the bandersnatch program to run commands received by the REPL server.
     */
    async eval(line, context, file, cb) {
        try {
            const result = await this.program.run(line.trim());
            this.successHandler(result);
        }
        catch (error) {
            this.errorHandler(error);
        }
        // Since we stop the server when a command is executed (by listening to the
        // 'run' event in the constructor), we need to start a new instance when the
        // command is finished.
        this.start();
        // The result passed to this function is printed by the Node REPL server,
        // but we don't want to use that, so we pass undefined instead.
        cb(null, undefined);
    }
}
