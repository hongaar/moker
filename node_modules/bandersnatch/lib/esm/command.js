var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Argument } from './argument.js';
import { Option } from './option.js';
import { prompter } from './prompter.js';
function isArgument(obj) {
    return obj instanceof Argument;
}
function isOption(obj) {
    return obj instanceof Option;
}
function isCommand(obj) {
    return obj instanceof Command;
}
/**
 * Creates a new command, which can be added to a program.
 */
export function command(command, options = {}) {
    return new Command(command, options);
}
export class Command {
    constructor(command, options = {}) {
        this.command = command;
        this.options = options;
        this.args = [];
    }
    /**
     * Set the command description.
     */
    description(description) {
        this.options.description = description;
        return this;
    }
    /**
     * Marks the command as hidden, i.e. not visible in autocomplete or help
     * output.
     */
    hidden() {
        this.options.hidden = true;
        return this;
    }
    /**
     * Adds a new positional argument to the command.
     * This is shorthand for `.add(argument(...))`
     */
    argument(name, options) {
        this.add(new Argument(name, options));
        return this;
    }
    /**
     * Adds a new option to the command.
     * This is shorthand for `.add(option(...))`
     */
    option(name, options) {
        this.add(new Option(name, options));
        return this;
    }
    /**
     * This is the base method for adding arguments, options and commands, but it
     * doesn't provide type hints. Use `.argument()` and `.option()` instead.
     */
    add(obj) {
        if (isArgument(obj)) {
            // If last argument is variadic, we should not add more arguments. See
            // https://github.com/yargs/yargs/blob/master/docs/advanced.md#variadic-positional-arguments
            const allArguments = this.getArguments();
            const lastArgument = allArguments[allArguments.length - 1];
            if (lastArgument && lastArgument.isVariadic()) {
                throw new Error("Can't add more arguments.");
            }
            this.args.push(obj);
        }
        else if (isOption(obj)) {
            this.args.push(obj);
        }
        else if (isCommand(obj)) {
            obj.setParentCommand(this);
            this.args.push(obj);
        }
        else {
            console.log('add', { obj, command: this });
            throw new Error('Not implemented.');
        }
        return this;
    }
    /**
     * Mark as the default command.
     */
    default() {
        this.command = '$0';
        return this;
    }
    /**
     * Provide a function to execute when this command is invoked.
     */
    action(fn) {
        this.handler = fn;
        return this;
    }
    /**
     * Set the parent command. This method may change at any time, not
     * intended for public use.
     *
     * @private
     */
    setParentCommand(parentCommand) {
        this.parent = parentCommand;
    }
    getArguments() {
        return this.args.filter(isArgument);
    }
    getOptions() {
        return this.args.filter(isOption);
    }
    getCommands() {
        return this.args.filter(isCommand);
    }
    /**
     * Returns a fully qualified command name (including parent command names).
     */
    getFqn() {
        if (!this.command) {
            throw new Error("Can't get command FQN for default commands.");
        }
        const command = Array.isArray(this.command) ? this.command[0] : this.command;
        if (this.parent) {
            return `${this.parent.getFqn()} ${command}`;
        }
        return command;
    }
    /**
     * Calls the command() method on the passed in yargs instance and returns it.
     * Takes command runner.
     * See https://github.com/yargs/yargs/blob/master/docs/advanced.md#providing-a-command-module
     */
    toYargs(yargs, commandRunner) {
        return yargs.command(this.toModule(commandRunner));
    }
    /**
     * Returns a yargs module for this command. Takes command runner, which is
     * passed down to getHandler and getBuilder functions.
     */
    toModule(commandRunner) {
        const module = {
            command: this.toYargsCommand(),
            aliases: [],
            describe: this.options.hidden ? false : this.options.description || '',
            builder: this.getBuilder(commandRunner),
            // @ts-ignore Our handler returns a different type than void
            handler: this.getHandler(commandRunner),
        };
        return module;
    }
    /**
     * Returns a formatted command which can be used in the `command()` function
     * of yargs.
     */
    toYargsCommand() {
        if (!this.command) {
            throw new Error('Command name must be set');
        }
        const args = this.getArguments()
            .map((arg) => arg.toCommand())
            .join(' ');
        if (args !== '') {
            return Array.isArray(this.command)
                ? [`${this.command[0]} ${args}`, ...this.command.slice(1)]
                : `${this.command} ${args}`;
        }
        return this.command;
    }
    /**
     * Returns the builder function to be used with `yargs.command()`. Takes
     * command runner.
     */
    getBuilder(commandRunner) {
        return (yargs) => {
            // Call toYargs on each argument and option to add it to the command.
            yargs = [...this.getArguments(), ...this.getOptions()].reduce((yargs, arg) => arg.toYargs(yargs), yargs);
            // Call toYargs on each subcommand to add it to the command.
            yargs = this.getCommands().reduce((yargs, cmd) => cmd.toYargs(yargs, commandRunner), yargs);
            return yargs;
        };
    }
    /**
     * Wraps the actual command handler to insert prompt and handler logic.
     */
    getHandler(commandRunner) {
        return async (argv) => {
            const prompterInstance = prompter([...this.getArguments(), ...this.getOptions()], argv);
            let promise = prompterInstance.prompt();
            promise = promise.then((_a) => {
                var { _, $0, __promise } = _a, args = __rest(_a, ["_", "$0", "__promise"]);
                // @todo coerce all types and remove coerce option from baseArg
                if (this.handler) {
                    return this.handler(args, commandRunner);
                }
                // Display help if this command contains sub-commands
                if (this.getCommands().length) {
                    return commandRunner(`${this.getFqn()} --help`);
                }
                throw new Error('No handler defined for this command.');
            });
            // Save promise chain on argv instance, so we can access it in parse
            // callback.
            // @todo Upgrade to native async handlers in yarn 17
            argv.__promise = promise;
            return promise;
        };
    }
}
