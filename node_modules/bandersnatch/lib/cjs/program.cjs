"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Program = exports.program = void 0;

const events_1 = require("events");

const os_1 = __importDefault(require("os"));

const path_1 = __importDefault(require("path"));

const yargs_1 = __importDefault(require("yargs/yargs"));

const command_js_1 = require("./command.cjs");

const history_js_1 = require("./history.cjs");

const repl_js_1 = require("./repl.cjs");

const utils_js_1 = require("./utils.cjs");

const DEFAULT_PROMPT = '> ';
const DEFAULT_HISTORY_FILE = '.bandersnatch_history';
/**
 * Creates a new bandersnatch program.
 */

function program(options = {}) {
  return new Program(options);
}

exports.program = program;

function extractCommandFromProcess() {
  return process.argv.slice(2);
}

class Program extends events_1.EventEmitter {
  constructor(options = {}) {
    super();
    this.options = options;
    this.commands = []; // Set default prompt

    if (typeof this.options.prompt === 'undefined') {
      this.options.prompt = DEFAULT_PROMPT;
    } // Set default historyFile


    if (typeof this.options.historyFile === 'undefined') {
      this.options.historyFile = path_1.default.join(os_1.default.homedir(), DEFAULT_HISTORY_FILE);
    } // Set default exit handler


    if (this.options.exit === true || typeof this.options.exit === 'undefined') {
      this.options.exit = () => process.exit();
    }

    if (this.options.historyFile !== null) {
      this.history = (0, history_js_1.history)(this);
    }
  }
  /**
   * Set the program description.
   */


  description(description) {
    this.options.description = description;
    return this;
  }
  /**
   * Sets a custom REPL prompt.
   */


  prompt(prompt) {
    this.options.prompt = prompt;
    return this;
  }
  /**
   * Create a new yargs instance. This method may change at any time, not
   * intended for public use.
   *
   * @private
   */


  createYargsInstance(overrideParserConfiguration) {
    let yargs = (0, yargs_1.default)();
    this.options.description && yargs.usage(this.options.description); // Help accepts boolean

    yargs.help(this.options.help !== false); // Version must be false or undefined

    this.options.version !== false ? yargs.version() : yargs.version(false); // Pass yargs parser options if defined

    if (typeof this.options.parserConfiguration !== 'undefined') {
      yargs = yargs.parserConfiguration(Object.assign(Object.assign({}, this.options.parserConfiguration), overrideParserConfiguration));
    } // Non-configurable options


    yargs.recommendCommands();
    yargs.strict();
    yargs.demandCommand(); // Hidden completion command

    yargs.completion('completion', false); // Custom fail function.

    yargs.fail(this.failHandler.bind(this)); // In case we're in a REPL session, do not exit on errors.

    yargs.exitProcess(!this.isRepl()); // Add commands

    this.commands.forEach(command => {
      command.toYargs(yargs, command => {
        return this.run(command);
      });
    });
    return yargs;
  }
  /**
   * Adds a new command to the program.
   */


  add(command) {
    this.commands.push(command);
    return this;
  }
  /**
   * Adds a new command to the program and marks it as the default command.
   */


  default(command) {
    this.commands.push(command.default());
    return this;
  }
  /**
   * Evaluate command (or process.argv) and return promise.
   */


  run(command) {
    const cmd = command || extractCommandFromProcess();
    this.emit('run', cmd); // Return promise resolving to the return value of the command
    // handler.

    return new Promise((resolve, reject) => {
      // @ts-ignore Not sure why this is needed?
      this.createYargsInstance().parse(cmd, {}, (err, argv, output) => {
        // We don't use yargs 17 promise style argv
        if ((0, utils_js_1.isPromise)(argv)) {
          throw new Error('argv is of unexpected type');
        }
        /**
         * From the yargs docs:
         * > any text that would have been output by yargs to the terminal,
         * > had a callback not been provided.
         * http://yargs.js.org/docs/#api-parseargs-context-parsecallback
         *
         * Seems that this is primarily used for built-in commands like
         * --version and --help.
         */


        if (output) {
          console.log(output);
        }
        /**
         * From the yargs docs:
         * > Populated if any validation errors raised while parsing.
         * http://yargs.js.org/docs/#api-parseargs-context-parsecallback
         * This seems to be incorrect though, and err is populated when any
         * error is thrown inside the command handler.
         */


        if (err) {// Ignore err value, which encourages users to deliberately handle
          // error conditions in their programs.
        }

        if ((0, utils_js_1.isPromise)(argv.__promise)) {
          // Delegate resolve/reject to promise returned from handler
          argv.__promise.then(resolve).catch(reject);
        } else {
          // Resolve with undefined if promise is not available, which is the
          // case with e.g. --version and --help. It should be noted that
          // this might need to be filtered when e.g. printing resolved values
          // from command handlers in a .then() function.
          resolve(undefined);
        }
      }).catch(() => {});
    });
  }
  /**
   * Run event loop which reads command from stdin.
   */


  repl() {
    this.replInstance = (0, repl_js_1.repl)(this); // Add exit command

    if (typeof this.options.exit === 'function') {
      this.add((0, command_js_1.command)('exit').description('Exit the application').action(this.options.exit));
    }

    if (this.history) {
      this.replInstance.attachHistory(this.history);
    }

    this.replInstance.start();
    return this.replInstance;
  }
  /**
   * When argv is set, run the program, otherwise start repl loop.
   */


  runOrRepl() {
    return extractCommandFromProcess().length ? this.run() : this.repl();
  }
  /**
   * Returns `true` if program is running a repl loop, `false` otherwise.
   */


  isRepl() {
    return !!this.replInstance;
  }
  /**
   * Method to execute when a failure occurs, rather than printing the failure
   * message.
   *
   * Called with the failure message that would have been printed, the Error
   * instance originally thrown and yargs state when the failure occured.
   */


  failHandler(msg, err, yargs) {
    if (msg) {
      // Simply throw validation messages to reject runner promise
      throw new Error(msg);
    }
  }

}

exports.Program = Program;
//# sourceMappingURL=program.cjs.map
