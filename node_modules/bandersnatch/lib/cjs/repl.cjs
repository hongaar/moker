"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Repl = exports.repl = void 0;

const repl_1 = __importDefault(require("repl"));

const string_argv_1 = require("string-argv");

const autocompleter_js_1 = require("./autocompleter.cjs");
/**
 * Create new REPL instance.
 */


function repl(program) {
  return new Repl(program);
}

exports.repl = repl;

class Repl {
  constructor(program) {
    this.program = program;

    this.successHandler = () => {};

    this.errorHandler = reason => console.error(reason);

    this.autocompleter = (0, autocompleter_js_1.autocompleter)(program); // Stop the server to avoid eval'ing stdin from prompts

    this.program.on('run', () => {
      this.stop();
    });
  }

  attachHistory(history) {
    this.history = history;
  }
  /**
   * Start the REPL server. This method may change at any time, not
   * intended for public use.
   *
   * @private
   */


  async start() {
    var _a;

    this.server = repl_1.default.start({
      prompt: this.program.options.prompt,
      eval: this.eval.bind(this),
      completer: this.completer.bind(this),
      ignoreUndefined: true
    }); // Setup history

    (_a = this.history) === null || _a === void 0 ? void 0 : _a.hydrateReplServer(this.server); // Fixes bug with hidden cursor after enquirer prompt, this is identical to
    // the enquirer method Prompt.cursorShow()

    process.stdout.write(`\u001b[?25h`);
  }

  stop() {
    var _a;

    (_a = this.server) === null || _a === void 0 ? void 0 : _a.close();
  }
  /**
   * Emulates promise.then, but saves the callback instead to be executed on
   * each command which resolves.
   */


  then(cb) {
    this.successHandler = cb;
    return this;
  }
  /**
   * Emulates promise.catch, but saves the callback instead to be executed on
   * each command which rejects.
   */


  catch(cb) {
    this.errorHandler = cb;
    return this;
  }
  /**
   * Invokes the autocompleter and passes results to the REPL server.
   */


  async completer(line, cb) {
    function addSpace(str) {
      return `${str} `;
    }

    const argv = (0, string_argv_1.parseArgsStringToArgv)(line);
    const current = argv.slice(-1).toString();
    const completions = (await this.autocompleter.completions(argv)).map(addSpace);
    let hits = completions.filter(completion => completion.startsWith(current)); // Show all completions if none found

    cb(null, [hits.length ? hits : completions, current]);
  }
  /**
   * Uses the bandersnatch program to run commands received by the REPL server.
   */


  async eval(line, context, file, cb) {
    try {
      const result = await this.program.run(line.trim());
      this.successHandler(result);
    } catch (error) {
      this.errorHandler(error);
    } // Since we stop the server when a command is executed (by listening to the
    // 'run' event in the constructor), we need to start a new instance when the
    // command is finished.


    this.start(); // The result passed to this function is printed by the Node REPL server,
    // but we don't want to use that, so we pass undefined instead.

    cb(null, undefined);
  }

}

exports.Repl = Repl;
//# sourceMappingURL=repl.cjs.map
