import { ArgumentsCamelCase, Argv } from 'yargs';
import { Argument, ArgumentOptions } from './argument.js';
import { InferArgType } from './baseArg.js';
import { Option, OptionOptions } from './option.js';
export declare type YargsArguments<T = {}> = ArgumentsCamelCase<T>;
declare type CommandOptions = {
    /**
     * Command description. Can also be set by calling
     * `command(...).description(...)`.
     *
     * Defaults to `undefined`.
     */
    description?: string;
    /**
     * When set to true, creates a hidden command not visible in autocomplete or
     * help output. Can also be set by calling `command(...).hidden()`.
     *
     * Default to `false`.
     */
    hidden?: boolean;
};
declare type CommandRunner = (command: string) => Promise<unknown>;
export interface HandlerFn<T> {
    (args: T, commandRunner: CommandRunner): Promise<any> | any;
}
/**
 * Creates a new command, which can be added to a program.
 */
export declare function command<T = {}>(command?: string | string[], options?: CommandOptions): Command<T>;
export declare class Command<T = {}> {
    private command?;
    private options;
    private args;
    private handler?;
    private parent?;
    constructor(command?: string | string[] | undefined, options?: CommandOptions);
    /**
     * Set the command description.
     */
    description(description: string): this;
    /**
     * Marks the command as hidden, i.e. not visible in autocomplete or help
     * output.
     */
    hidden(): this;
    /**
     * Adds a new positional argument to the command.
     * This is shorthand for `.add(argument(...))`
     */
    argument<K extends string, O extends ArgumentOptions>(name: K, options?: O): Command<T & { [key in K]: InferArgType<O, string>; }>;
    /**
     * Adds a new option to the command.
     * This is shorthand for `.add(option(...))`
     */
    option<K extends string, O extends OptionOptions>(name: K, options?: O): Command<T & { [key in K]: InferArgType<O, unknown>; }>;
    /**
     * This is the base method for adding arguments, options and commands, but it
     * doesn't provide type hints. Use `.argument()` and `.option()` instead.
     */
    add(obj: Argument | Option | Command<any>): this;
    /**
     * Mark as the default command.
     */
    default(): this;
    /**
     * Provide a function to execute when this command is invoked.
     */
    action(fn: HandlerFn<T>): this;
    /**
     * Set the parent command. This method may change at any time, not
     * intended for public use.
     *
     * @private
     */
    setParentCommand(parentCommand: Command<any>): void;
    private getArguments;
    private getOptions;
    private getCommands;
    /**
     * Returns a fully qualified command name (including parent command names).
     */
    private getFqn;
    /**
     * Calls the command() method on the passed in yargs instance and returns it.
     * Takes command runner.
     * See https://github.com/yargs/yargs/blob/master/docs/advanced.md#providing-a-command-module
     */
    toYargs(yargs: Argv, commandRunner: CommandRunner): Argv<T>;
    /**
     * Returns a yargs module for this command. Takes command runner, which is
     * passed down to getHandler and getBuilder functions.
     */
    private toModule;
    /**
     * Returns a formatted command which can be used in the `command()` function
     * of yargs.
     */
    private toYargsCommand;
    /**
     * Returns the builder function to be used with `yargs.command()`. Takes
     * command runner.
     */
    private getBuilder;
    /**
     * Wraps the actual command handler to insert prompt and handler logic.
     */
    private getHandler;
}
export {};
